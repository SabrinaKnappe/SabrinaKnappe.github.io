---
layout: post
title: Iteration 1
subtitle: Creating a note class in processing.
cover-img: /assets/img/iteration1/notes.png
thumbnail-img: /assets/img/iteration1/notes.png
share-img: /assets/img/iteration1/notes.png
tags: [haptics, coursework, iterations]
---
This iteration, my team and I started by brainstorming what we wanted to achieve with our project. We came up with a list of wants, needs, and nice to haves. 

**Need to have**
  - User-driven exploration
  - Tempo-driven guidance
  - Inspiration: going over scores in choir
  - Music reading
  - Support for note duration, tempo, pitch
**Want to have**
  - Music editing
  - Support for common accidentals (sharps/flats)
  - “Sticky track” to show where lines are in the music (basically a bump you cross when you go between spots in music)
**Nice to have**
  - Drag and drop functionality for haply for music editing
  - Pared down interface (focus on fundamentals, so maybe only show melody…)
  - Ability to import a song and isolate the melody (at this point this is really blue sky thinking)

Based on these goals, we decided to prioritize getting a working prototype with 

My two primary contributions were in writing the code for 
{% highlight processing%}
  double durationMs() {
    Fraction shape= this.getDuration();
    System.out.println("dalmation: "+shape);
    //the calls for time signature and tempo are probably wrong
    OrderedMusicElement e = (OrderedMusicElement) this;
    double tempo = e.parent.tempo;
    System.out.println("Tempo: "+tempo);
    OrderedMusicElement tsObj = e.getPrevious(TimeSignature.class);
    Fraction tsFrac;
    if (tsObj != null) {
      TimeSignature ts = (TimeSignature) e.getPrevious(TimeSignature.class);
      println("Time sig:", ts.num, ts.den);
      tsFrac = Fraction.of(1, ts.den);
    }
    else {
      tsFrac = Fraction.of(1, 4);
    }
    double durationMs = 60/tempo;
    Fraction shape2timeFrac= (shape.divide(tsFrac));
    System.out.println("shape2time: "+shape2timeFrac);
    double shape2time= ((double) shape2timeFrac.getNumerator())/((double) shape2timeFrac.getDenominator());
    durationMs= durationMs*shape2time*1000;
    System.out.println("duration: "+durationMs);
    return durationMs;
  }
{% endhighlight %}

{% highlight processing %}
  void getSine(){
    //the notes can be found by taking the starting note and doing the following calculation: Freq = note x 2^N/12
    //the clef will determine the starting note
    Clef c = (Clef) this.getPrevious(Clef.class);
    ClefShape sh = c.shape;
    if(sh== null){
      sh= ClefShape.G;
    }
    float refnote= 0.0;
    if (sh == ClefShape.G) {  //treble clef
      //the first note is the one on the first staff line- so for this clef it is E4
      refnote= 329.628;
    }
    else if (sh == ClefShape.C) { //baritone clef??
      //the reference note is F3
      refnote= 174.61;
    }
    else {      // ClefShape.F aka bass clef
      //the reference note is G2
      refnote= 98.00;
    }
    System.out.println(this.location);
    float loc= float(this.location);
    float frequency= refnote* (float) Math.pow(2, (loc/12.0));
    System.out.println(frequency);
    sine.freq(frequency);
    sine.amp(0.5);
    
  }
{% end highlight %}